#include <iostream>
#include "network_Can_generated.h" // This was generated by `flatc`.
 
using namespace NetworkModels::CAN; // Specified in the schema.

int main() {
// Create a `FlatBufferBuilder`, which will be used to create our
// monsters' FlatBuffers.
flatbuffers::FlatBufferBuilder builder(1024);

uint8_t frameId = 0;
uint8_t payload_Data[] = {0,1,2,3};
auto payload_vector = builder.CreateVector(payload_Data,4);

auto payloadLen = 0;
bool rtr = 0;
MessageTiming m ;

MessageTiming v ={m.send_request(),m.arbitration(),m.reception()};


auto frame1 = CreateFrame(builder,frameId,payload_vector,payloadLen,rtr,FrameType_standard_frame);

auto meta_frame = CreateMetaFrame(builder,BufferStatus_None,BufferDirection_Tx,CanFDIndicator_can,frame1,&v);


std::vector<flatbuffers::Offset<MetaFrame>> MetaFrameVector;
MetaFrameVector.push_back(meta_frame);

auto metaFrame = builder.CreateVector(MetaFrameVector);
auto fileR = CreateRegisterFile(builder,metaFrame);

builder.Finish(fileR);

uint8_t *buf = builder.GetBufferPointer();
int size = builder.GetSize(); 

std::cout << "size of buffer : " << size << std::endl; 

auto metaData = GetRegisterFile(buf);

auto bufferData = metaData->buffer();

auto frameData = bufferData->Get(0)->frame();

auto client_payload = frameData->payload();

for (size_t i = 0; i < client_payload->size(); i++)
{
    printf("%d",client_payload->Get(i));
}

auto payload_timestamp = bufferData->Get(0)->timing();

 printf("%d",payload_timestamp);

}

