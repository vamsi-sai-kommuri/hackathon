#include <iostream>
#include "network_Can_generated.h" // This was generated by `flatc`.
#include "flatbuffers/idl.h"
 #include "flatbuffers/util.h"
  #include <fstream> 
using namespace NetworkModels::CAN; // Specified in the schema.

int main() {
// Create a `FlatBufferBuilder`, which will be used to create our
// monsters' FlatBuffers.
flatbuffers::FlatBufferBuilder builder(1024);

uint8_t frameId = 0;
uint8_t payload_Data[] = {0,1,2,3};
auto payload_vector = builder.CreateVector(payload_Data,4);

auto payloadLen = 0;
bool rtr = 0;
MessageTiming m ;

MessageTiming v ={m.send_request(),m.arbitration(),m.reception()};


auto frame1 = CreateFrame(builder,frameId,payload_vector,payloadLen,rtr,FrameType_standard_frame);

auto meta_frame = CreateMetaFrame(builder,BufferStatus_None,BufferDirection_Tx,CanFDIndicator_can,frame1,&v);


std::vector<flatbuffers::Offset<MetaFrame>> MetaFrameVector;
MetaFrameVector.push_back(meta_frame);

auto metaFrame = builder.CreateVector(MetaFrameVector);
auto fileR = CreateRegisterFile(builder,metaFrame);

builder.Finish(fileR);


uint8_t *buf = builder.GetBufferPointer();
int size = builder.GetSize(); 

std::ofstream ofile("data.bin", std::ios::binary);
ofile.write((char *)buf, size);
ofile.close();

    std::ifstream infile;
    infile.open("data.bin", std::ios::binary | std::ios::in);
    infile.seekg(0,std::ios::end);
    int length = infile.tellg();
    infile.seekg(0,std::ios::beg);
    char *data = new char[length];
    infile.read(data, length);
    infile.close();
  


std::cout << "size of buffer : " << size << std::endl; 

auto metaData = GetRegisterFile(data);

auto bufferData = metaData->buffer();

auto frameData = bufferData->Get(0)->frame();

auto client_payload = frameData->payload();

for (size_t i = 0; i < client_payload->size(); i++)
{
    printf("%d",client_payload->Get(i));
}

auto payload_timestamp = bufferData->Get(0)->timing();

 printf("%d",payload_timestamp);

}

