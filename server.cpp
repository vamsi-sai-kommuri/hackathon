#include <iostream>
#include <winsock2.h>
#include "flatbuffers/flatbuffers.h"
//#include "network_Can_generated.h"
#include <fstream> // C++ header file for file access
#include "flatbuffers/idl.h"
 #include "flatbuffers/util.h"

 
#include "network_Can_generated.h" // This was generated by `flatc`.

#include <typeinfo>
// This was generated by `flatc`.
using namespace std;
using namespace NetworkModels::CAN; // Specified in the schema.

#pragma comment(lib,"ws2_32.lib") // Winsock Library
#pragma warning(disable:4996) 

#define BUFLEN 4096
#define PORT 8888

int main()
{
    system("title UDP Server");

    flatbuffers::FlatBufferBuilder builder(1024);

    sockaddr_in server, client;

    // initialise winsock
    WSADATA wsa;
    printf("Initialising Winsock...");
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
    {
        printf("Failed. Error Code: %d", WSAGetLastError());
        exit(0);
    }
    printf("Initialised.\n");

    // create a socket
    SOCKET server_socket;
    if ((server_socket = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
    {
        printf("Could not create socket: %d", WSAGetLastError());
    }
    printf("Socket created.\n");

    // prepare the sockaddr_in structure
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(PORT);


    // bind
    if (bind(server_socket, (sockaddr*)&server, sizeof(server)) == SOCKET_ERROR)
    {
        printf("Bind failed with error code: %d", WSAGetLastError());
        exit(EXIT_FAILURE);
    }
    puts("Bind done.");

    while (true)
    {
        printf("Waiting for data...\n");
        fflush(stdout);
        char *message = new char[BUFLEN];
        

        // try to receive some data, this is a blocking call
        int message_len;
        int slen = sizeof(sockaddr_in);
        if (message_len = recvfrom(server_socket, message, BUFLEN, 0, (sockaddr*)&client, &slen) == SOCKET_ERROR)
        {
            printf("recvfrom() failed with error code: %d", WSAGetLastError());
            exit(0);
        }

        // print details of the client/peer and the data received
        printf("Received packet from %s:%d\n", inet_ntoa(client.sin_addr), ntohs(client.sin_port));
      

         auto metaData = GetRegisterFile(message);

        auto bufferData = metaData->buffer();

        std::vector<flatbuffers::Offset<MetaFrame>> MetaFrameVector;

        for (size_t i = 0; i < bufferData->size(); i++){

              auto frameData = bufferData->Get(i)->frame();
              uint8_t frameId = frameData->frame_id();
              uint8_t payload_Data[] = {0,1,2,4};
              auto payload_vector = builder.CreateVector(payload_Data,4);
              auto payloadLen = frameData->length();
              bool rtr = frameData->rtr();
              auto FrameType = frameData->type();

               auto frame1 = CreateFrame(builder,frameId,payload_vector,payloadLen,rtr,FrameType);
              
              auto bufferStatus =  bufferData->Get(i)->status();
              auto bufferDirection =  bufferData->Get(i)->direction();
              auto canIndicator =  bufferData->Get(i)->canFD_enabled();
              auto messageTiming = bufferData->Get(i)->timing();

              auto meta_frame = CreateMetaFrame(builder,bufferStatus,bufferDirection,canIndicator,frame1,messageTiming);
               MetaFrameVector.push_back(meta_frame);

        }

        auto metaFrame = builder.CreateVector(MetaFrameVector);
        auto fileR = CreateRegisterFile(builder,metaFrame);   

        builder.Finish(fileR);
        uint8_t *buf = builder.GetBufferPointer();;

        

        // reply the client with 2the same data
        if (sendto(server_socket, (char *)buf, BUFLEN, 0, (sockaddr*)&client, sizeof(sockaddr_in)) == SOCKET_ERROR)
        {
            printf("sendto() failed with error code: %d", WSAGetLastError());
            return 3;
        }
         exit(0);
    }

    closesocket(server_socket);
    WSACleanup();
}